<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: Getting Started</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: Getting Started</h1>

    <section>

<header>
    

    <h2>Getting Started</h2>
</header>

<article>
    <p><code>graphgram</code> is a library for generating graphs using a transformative graph grammar.
This is useful if you want random graphs that have predictable structural motifs or patterns in them.
The motivating use case is procedural generation of story paths or maps in interactive fiction (i.e. games),
and the pioneering example of this is Joris Dormans' roguelike <em>Unexplored</em>
as described in <a href="https://www.rockpapershotgun.com/2017/03/10/how-unexplored-generates-great-roguelike-dungeons/">this RPS article</a>.
(A formal mathematical introduction to graph grammars can be found in <a href="http://www.its.caltech.edu/~matilde/GraphGrammarsLing.pdf">these slides by Matilde Marcolli</a>.)</p>
<p>The way that <code>graphgram</code> works is as follows. A basic graph grammar consists of a set of <em>transformation rules</em>.
Each such rule contains, at minimum, a <em>left-hand side</em> and a <em>right-hand side</em>: the rule has the form <em>LHS → RHS</em>.</p>
<ul>
<li>The left-hand side is a pattern that is used to match a subgraph of the current graph, using <a href="https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">Ullman's 1976 subgraph isomorphism search algorithm</a>.</li>
<li>The right-hand side specifies a subgraph that will be pasted in as a replacement for the matching subgraph.</li>
</ul>
<p>Beyond simply matching subgraph topologies, <code>graphgram</code> offers considerable flexibility in the way that the LHS pattern-matching occurs.
Each node and edge in the graph can have a <em>label</em> which can be a string or an arbitrary JSON object.
There is a simple query language for matching labels (or the user can define their own label-matching function).
The grammar specification also allows for constraints limiting the number and type of transformation rules that can be applied to generate any single graph.</p>
<p>The library can be called via the API of the <a href="Grammar.html"><code>Grammar</code></a> class, or using the command-line tool <code>bin/transform.js</code>.</p>
<p>Grammars are specified using a <a href="../schema_doc.html">JSON schema that is documented here</a>.</p>
<p>All graphs generated by <code>graphgram</code> are directed.
Undirected edges can be represented using two directed edges, one pointing forwards and one backwards.</p>
<h2>Dungeon grammar</h2>
<p>The default grammar for the CLI, for demo purposes, is a dungeon-generation grammar that is fairly close to the following:</p>
<pre class="prettyprint source"><code>{
  name: 'dungeon-grammar',
  start: 'START',
    rules:
    [{ lhs: 'START', rhs: ['entrance', 'x', 'boss'] },
    { lhs: 'x', rhs: ['x','x'], limit: 3 },
    { lhs: 'x', rhs: { node: ['fork', 'x', 'die', 'x'], edge: [[0,1],[1,2],[0,3]] }, type: 'ending', limit: 3 },
    { lhs: 'x', rhs: { node: ['fork', 'x', 'live', 'x'], edge: [[0,1],[1,2],[0,3]] }, type: 'ending', limit: 3 },
    { lhs: 'x', rhs: { node: ['fork', 'x', 'x', 'x'], edge: [[0,1],[0,2],[1,3],[2,3]] }, type: 'fork', limit: 2, delay: 2 },
    { lhs: 'x', rhs: { node: ['crossroads', 'x', 'x', 'x', 'x'], edge: [[0,1],[0,2],[0,3],[1,4],[2,4],[3,4]] }, type: 'fork', limit: 1, delay: 2 },
    { lhs: 'x', rhs: { node: ['door', 'x1', 'x'], edge: [[0,1,'enter'],[1,2,'exit'],[0,2,'bypass']] }, limit: 3 },
    { lhs: 'x', rhs: { node: ['fork', 'x', 'x', 'x', 'rescue', 'x', 'x'], edge: [[0,1],[1,2],[2,3],[0,3],[3,4],[4,5],[5,6],[3,6],[1,4,'rumor']] }, type: 'rescue', limit: 1 },
    { lhs: 'x', rhs: { node: ['door', 'x1', 'x', 'rescue', 'x', 'x'], edge: [[0,1,'enter'],[1,2,'exit'],[0,2,'bypass'],[2,3],[3,4],[4,5],[2,5],[1,3,'rumor']] }, type: 'rescue', limit: 1 },
    { lhs: 'x', rhs: { node: ['chest', 'chest_contents', 'x'], edge: [[0,1,'open'],[1,2],[0,2,'ignore']] }, limit: 3 },
    { lhs: 'chest_contents', rhs: 'trap', weight: 2 },
    { lhs: 'chest_contents', rhs: 'treasure' },
    { lhs: 'chest_contents', rhs: 'weapon' },
    { lhs: 'x', rhs: { node: ['vial', 'vial_contents', 'x'], edge: [[0,1,'drink'],[1,2],[0,2,'ignore']] }, limit: 3 },
    { lhs: 'vial_contents', rhs: 'potion' },
    { lhs: 'vial_contents', rhs: 'poison' },
    { lhs: 'x', rhs: 'x1', delay: 10 },
    { lhs: 'x1', rhs: 'trap' },
    { lhs: 'x1', rhs: 'monster' },
    { lhs: 'x1', rhs: 'weapon', limit: 2 },
    { lhs: 'x1', rhs: 'treasure', limit: 3 },
    { lhs: 'x1', rhs: 'scenery', weight: 2 }
    ]
}
</code></pre>
<p>The full flexibility of matching any subgraph and replacing it with another subgraph of arbitrary topology (possibly with some overlap/reuse of nodes and/or edges from the matched subgraph) can be quite daunting and is probably overkill for most purposes.
In recognition of this, <code>graphgram</code> offers a few syntactical shortcuts for common types of transformation rule and graph
(corresponding to sequence grammars, context-free grammars, and so on).
These are fully described in the documentation for the <a href="../schema_doc.html">JSON schema</a> for the `Grammar`` class.</p>
<p>One of these syntactical shortcuts is heavily used by the above dungeon grammar:
all the transformation rules in that grammar have a single node on the left-hand side.
This means that the subgraph matching algorithm is not being heavily exercised by this grammar;
it is effectively a context-free node replacement grammar.</p>
<p>The simplest kind of rule in this grammar has the form:</p>
<pre class="prettyprint source"><code>{ lhs: 'chest_contents', rhs: 'weapon' },
</code></pre>
<p>This simply means &quot;replace a node whose label is <code>chest_contents</code> with a node whose label is <code>weapon</code>&quot;.</p>
<p>An example of a slightly more elaborate rule is</p>
<pre class="prettyprint source"><code>{ lhs: 'START', rhs: ['entrance', 'x', 'boss'] }
</code></pre>
<p>This replaces the node labeled <code>START</code> with a sequence of three nodes:
<code>entrance</code>→<code>x</code>→<code>boss</code>.</p>
<p>The edges connecting consecutive nodes are added by default when an array of node labels is given.
This corresponds to inserting a sequence of nodes at a particular point (as in a string transformation grammar).
For an example of a rule where the replacement subgraph is not just a linear chain, so that its topology must be specified explicitly,
consider the following:</p>
<pre class="prettyprint source"><code>{ lhs: 'x', rhs: { node: ['fork', 'x', 'die', 'x'], edge: [[0,1],[1,2],[0,3]] } },
</code></pre>
<p>This replaces a node labeled <code>x</code> with a subgraph containing four nodes labeled (respectively)
<code>fork</code> (node 0), <code>x</code> (node 1), <code>die</code> (node 2) and <code>x</code> (node 3).
The <code>edge</code> clause in the <code>rhs</code> of this rule contains three tuples of the form <code>[v,w]</code> where <code>v</code> and <code>w</code> represent the indices of
(respectively) the <em>source</em> and <em>target</em> nodes in the replacement subgraph.
Thus, the subgraph contains a <code>fork</code> node that has edges to two new <code>x</code> nodes, the first of which then leads to a <code>die</code> node.
The first node on the RHS inherits the edges that are incoming to the LHS node, and the last node on the RHS inherits its outgoing edges
(this behavior can be overridden, as described in the JSON schema).</p>
<p>The actual rule that appears in the example grammar is slightly different from this:</p>
<pre class="prettyprint source"><code>{ lhs: 'x', rhs: { node: ['fork', 'x', 'die', 'x'], edge: [[0,1],[1,2],[0,3]] }, type: 'ending', limit: 3 },
</code></pre>
<p>The <code>type</code> and <code>limit</code> fields indicate that this rule has type &quot;<code>ending</code>&quot; and can only be used if fewer than 3 rules with that type have already been applied.</p>
<p>For examples of more sophisticated subgraph replacement rules that include context and nontrivial topology on the LHS,
as well as compound expressions for matching/replacing node and edge labels,
see the <a href="https://github.com/ihh/graphgram/blob/master/grammars/level.js">level.js</a> example grammar
which generates levels for the &quot;roguelike snakelike&quot; game <a href="http://nemato.de/">nemato.de</a>.</p>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Grammar.html">Grammar</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-getting-started.html">Getting Started</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Oct 10 2023 17:09:27 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>